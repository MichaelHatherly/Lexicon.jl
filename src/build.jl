# This file generated the Markdown documentation files.

# The @file macro generates the documentation for a particular file
# where the {{method1, methods2}} includes the documentation for each method
# via the `buildwriter` function.

# Currently this prints the methodtable followed by the docstring.

macro file(fn, md_string, m::Module) buildfile(fn, md_string, m) end

function generate_for(m::Module, file_names...; doc_dir="docs", gen_dir="_generated")
    eval(Expr(:toplevel, quote using $(symbol(m)) end))
    dd = joinpath(Pkg.dir(string(m)), doc_dir)
    for file_name in file_names
        eval(quote
            @file $(joinpath(dd, gen_dir, file_name)) $(open(readall, joinpath(dd, file_name))) $m
        end)
    end
end

buildfile(t, s::AbstractString, m::Module) = buildfile(t, Expr(:string, s), m)

buildfile(target, source::Expr, m::Module) = quote
    open(joinpath(dirname(@__FILE__), $(esc(target))), "w") do file
        println(" - '$($(esc(target)))'")
        println(file, "<!-- AUTOGENERATED. See 'doc/build.jl' for source. -->")
        $(Expr(:block, [buildwriter(arg, m) for arg in source.args]...))
    end
end

buildwriter(ex::Expr, m::Module) = :(print(file, $(esc(ex))))

buildwriter(t::AbstractString, m::Module) = Expr(:block,
    [buildwriter(p, iseven(n), m) for (n, p) in enumerate(split(t, r"{{|}}"))]...
)

buildwriter(part, isdef, m) = isdef ?
    begin
        parts = Expr(:vect, [:(($(parse(p))), $(local_doc(parse(p); from=m))) for p in filter(x -> strip(x) != "", split(part, r"\s*[, \n]\s*"))]...)
        quote
            for (f, docstring) in $(esc(parts))
                if isa(f, Function)
                    md_methodtable(file, f, $m)
                end
                if has_h1_to_h3(docstring)
                    println("WARN: docstring for ", f, " contains h1 - h3. ",
                          "This may confuse formatting.")
                end
                writemime(file, "text/plain", docstring)
                println(file)
            end
        end
    end :
    :(print(file, $(esc(part))))

function md_methodtable(io, f, m::Module)
    println(io, "### ", first(methods(f)).func.code.name)
    println(io, "```")

    # We only consider methods with are defined in the parent (project) directory
    pd = joinpath(Pkg.dir(), string(module_name(m)))
    meths = filter(x -> startswith(string(x.func.code.file), pd), methods(f))
    for (i, meth) in enumerate(meths)
        md_method(io, meth, i, m)
    end
    println(io, "```")
    print(io, "*Source:")
    for (i, meth) in enumerate(meths)
        print(io, " [", i, "](", method_link(meth), ")")
    end
    println(io, '*')
    println(io)
end
function md_method(io, meth, i, m::Module)
    # We only print methods with are defined in the parent (project) directory
    pd = joinpath(Pkg.dir(), string(module_name(m)))
    if !(startswith(string(meth.func.code.file), pd))
        return
    end
    print(io, i, "  ",  meth.func.code.name)
    tv, decls, file, line = Base.arg_decl_parts(meth)
    if !isempty(tv)
        Base.show_delim_array(io, tv, '{', ',', '}', false)
    end
    print(io, "(")
    print_joined(io, [isempty(d[2]) ? "$(d[1])" : "$(d[1])::$(d[2])" for d in decls],
                 ", ", ", ")
    print(io, ")")
    println(io)
end

function has_h1_to_h3(md::Markdown.MD)
    for i in 1:length(md)
        s = md[i]
        if isa(s, Markdown.Header) && typeof(s).parameters[1] <= 3
            return true
        end
    end
    return false
end

function method_link(meth)
    "#pass"
end


function local_doc(func; from = Main, include_submodules = true)
    if isa(func, Symbol)
        func = from.(func)
    end
    if isa(func, Module)
        # TODO work with submodules
        return from.__META__[func]
    end
    out = IOBuffer()
    for m in (include_submodules ? submodules(from) : Set([from]))
        if isdefined(m, :__META__)
            meta = m.__META__
            if haskey(meta, func)
                for each in meta[func].order
                    writemime(out, "text/plain", Base.Docs.doc(func, each))
                end
            end
        end
    end
    Markdown.parse(takebuf_string(out))
end

function submodules(mod::Module)
   out = Set([mod])
   for name in names(mod, true)
       if isdefined(mod, name)
           object = getfield(mod, name)
           validmodule(mod, object) && union!(out, submodules(object))
       end
   end
   out
end

validmodule(mod::Module, object::Module) = object ≠ mod && object ≠ Main
validmodule(::Module, other) = false
