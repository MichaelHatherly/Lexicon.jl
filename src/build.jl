# This file generated the Markdown documentation files.

# The @file macro generates the documentation for a particular file
# where the {{method1, methods2}} includes the documentation for each method
# via the `buildwriter` function.

# Currently this prints the methodtable followed by the docstring.

using LightGraphs


macro file(fn, md_string, m::Module) buildfile(fn, md_string, m) end

function files(file_names, m::Module; doc_dir="doc", gen_dir="_generated")
    dd = joinpath(Pkg.dir(string(m)), doc_dir)
    for file_name in file_names
        eval(quote
            @file $(joinpath(dd, gen_dir, file_name)) $(open(readall, joinpath(dd, file_name))) $m
        end)
    end
end

buildfile(t, s::AbstractString, m::Module) = buildfile(t, Expr(:string, s), m)

buildfile(target, source::Expr, m::Module) = quote
    open(joinpath(dirname(@__FILE__), $(esc(target))), "w") do file
        println(" - '$($(esc(target)))'")
        println(file, "<!-- AUTOGENERATED. See 'doc/build.jl' for source. -->")
        $(Expr(:block, [buildwriter(arg, m) for arg in source.args]...))
    end
end

buildwriter(ex::Expr, m::Module) = :(print(file, $(esc(ex))))

buildwriter(t::AbstractString, m::Module) = Expr(:block,
    [buildwriter(p, iseven(n), m) for (n, p) in enumerate(split(t, r"{{|}}"))]...
)

buildwriter(part, isdef, m) = isdef ?
    begin
        parts = Expr(:vect, [:(($(parse(p))), Base.Docs.@doc($(parse(p)))) for p in filter(x -> strip(x) != "", split(part, r"\s*[, \n]\s*"))]...)
        quote
            for (f, docstring) in $(esc(parts))
                if isa(f, Function)
                    md_methodtable(file, f, $m)
                end
                if has_h1_to_h3(docstring)
                    println("WARN: docstring for ", f, " contains h1 - h3. ",
                          "This may confuse formatting.")
                end
                writemime(file, "text/plain", docstring)
                println(file)
            end
        end
    end :
    :(print(file, $(esc(part))))

function md_methodtable(io, f, m::Module)
    println(io, "### ", first(methods(f)).func.code.name)
    println(io, "```")
    for meth in methods(f)
        md_method(io, meth, m)
    end
    println(io, "```")
end
function md_method(io, meth, m::Module)
    # We only print methods with are defined in the parent (project) directory
    pd = joinpath(Pkg.dir(), string(module_name(m)))
    if !(startswith(string(meth.func.code.file), pd))
        return
    end
    print(io, meth.func.code.name)
    tv, decls, file, line = Base.arg_decl_parts(meth)
    if !isempty(tv)
        Base.show_delim_array(io, tv, '{', ',', '}', false)
    end
    print(io, "(")
    print_joined(io, [isempty(d[2]) ? "$(d[1])" : "$(d[1])::$(d[2])" for d in decls],
                 ", ", ", ")
    print(io, ")")
    println(io)
end

function has_h1_to_h3(md)
    for i in 1:length(md)
        s = md[i]
        if isa(s, Markdown.Header) && typeof(s).parameters[1] <= 3
            return true
        end
    end
    return false
end

